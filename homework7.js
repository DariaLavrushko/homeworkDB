//1. Вывести названия двух произвольных треков с тегом new
db.tracks.aggregate([
    { $match: { tags: "new" } },
    { $sample: { size: 2 } },
    { $project: { title: 1, _id: 0 }}
])

//2. Вывести имя юзера с самым минимальным балансом
db.users.aggregate([
    { $sort: { balance: 1} },
    { $limit: 1 },
    { $project: { fullname: 1, _id: 0 }}
])

//3. Вывести имена юзеров, у которых есть треки
db.users.aggregate([
    {
        $lookup: {
            from: 'tracks', // название колл., откуда взять данные
            localField: '_id', // локальное поле
            foreignField: 'author_id', // внешнее поле
            as: 'tracks' // куда поместить результат
        }
    },
    {
        $match: { tracks: { $ne: [] } }
    },
    { $project: { fullname: 1, _id: 0 } }
])

//4. Используя метод aggregate(), вывести ко-во юзеров с балансом до 1000 EUR
db.users.aggregate([
    { $match: { balance: { $lt: 1000 } } },
    { $count: 'users_with_lte1000' }
])

//5. Также очень коротко опишите, как работает агрегация в MongoDB

//представляет собой конвеер (`pipeline`), 
//который содержит определенные этапы обработки (`stages`),
//принимающиеся в качестве массива аргументов:
//- `$match` фильтрация
//- `$sort` сортировка
//    - `-1` по убыванию
//    - `1` по возрастанию
//- `$project` проекция
//- `$limit` лимитирование
//- `$skip` пропустить (документы)
//- `$group` группировка
//- `$lookup` объединение коллекций
//- `$addFields` добавить поля
//- `$sample` получить произвольные документы
//- `$count` возвращает ко-во документов
//- `$unwind` развернуть массив
